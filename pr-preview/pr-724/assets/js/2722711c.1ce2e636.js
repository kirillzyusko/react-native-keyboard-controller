"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2202],{24237:(e,o,i)=>{i.r(o),i.d(o,{assets:()=>d,contentTitle:()=>n,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>l});var s=i(74848),r=i(28453);const t={slug:"mastering-keyboard-dismissal",title:"Mastering keyboard dismissal \ud83e\udd77\ud83c\udffc",authors:["kirill"],tags:["react-native","keyboard","dismiss","state","isVisible"],keywords:["react-native-keyboard-controller","keyboard","dismiss","state","isVisible"]},n=void 0,a={permalink:"/react-native-keyboard-controller/pr-preview/pr-724/blog/mastering-keyboard-dismissal",editUrl:"https://github.com/kirillzyusko/react-native-keyboard-controller/tree/main/docs/blog/2024-12-31-release-1-15/index.mdx",source:"@site/blog/2024-12-31-release-1-15/index.mdx",title:"Mastering keyboard dismissal \ud83e\udd77\ud83c\udffc",description:"Today I'm glad to announce a new 1.15.0 version of react-native-keyboard-controller \ud83c\udf89",date:"2024-12-31T00:00:00.000Z",tags:[{inline:!0,label:"react-native",permalink:"/react-native-keyboard-controller/pr-preview/pr-724/blog/tags/react-native"},{inline:!0,label:"keyboard",permalink:"/react-native-keyboard-controller/pr-preview/pr-724/blog/tags/keyboard"},{inline:!0,label:"dismiss",permalink:"/react-native-keyboard-controller/pr-preview/pr-724/blog/tags/dismiss"},{inline:!0,label:"state",permalink:"/react-native-keyboard-controller/pr-preview/pr-724/blog/tags/state"},{inline:!0,label:"isVisible",permalink:"/react-native-keyboard-controller/pr-preview/pr-724/blog/tags/is-visible"}],readingTime:2.48,hasTruncateMarker:!0,authors:[{name:"Kirill Zyusko",title:"Library author",url:"https://github.com/kirillzyusko",imageURL:"https://github.com/kirillzyusko.png",key:"kirill"}],frontMatter:{slug:"mastering-keyboard-dismissal",title:"Mastering keyboard dismissal \ud83e\udd77\ud83c\udffc",authors:["kirill"],tags:["react-native","keyboard","dismiss","state","isVisible"],keywords:["react-native-keyboard-controller","keyboard","dismiss","state","isVisible"]},unlisted:!1,nextItem:{title:"New OverKeyboardView component",permalink:"/react-native-keyboard-controller/pr-preview/pr-724/blog/over-keyboard-view"}},d={authorsImageUrls:[void 0]},l=[{value:"Changes to <code>.dismiss()</code> method",id:"changes-to-dismiss-method",level:2},{value:"<code>dismiss()</code> method now returns a promise",id:"dismiss-method-now-returns-a-promise",level:3},{value:"<code>dismiss()</code> now blurs input by default",id:"dismiss-now-blurs-input-by-default",level:3},{value:"<code>dismiss()</code> now accepts a <code>keepFocus</code> parameter",id:"dismiss-now-accepts-a-keepfocus-parameter",level:3},{value:"New <code>KeyboardController</code> API methods",id:"new-keyboardcontroller-api-methods",level:2},{value:"New <code>.isVisible()</code> method",id:"new-isvisible-method",level:3},{value:"New <code>.state()</code> method",id:"new-state-method",level:3},{value:"Better <code>KeyboardStickyView</code> and <code>KeyboardToolbar</code> interoperability",id:"better-keyboardstickyview-and-keyboardtoolbar-interoperability",level:2},{value:"<code>KeyboardToolbar</code> now accepts <code>KeyboardStickyView</code> props",id:"keyboardtoolbar-now-accepts-keyboardstickyview-props",level:3},{value:"<code>KeyboardStickyView</code> got new <code>enabled</code> prop",id:"keyboardstickyview-got-new-enabled-prop",level:3},{value:"<code>KeyboardEvents</code> metadata enhancements",id:"keyboardevents-metadata-enhancements",level:2},{value:"New <code>type</code> property",id:"new-type-property",level:3},{value:"New <code>appearance</code> property",id:"new-appearance-property",level:3},{value:"<code>KeyboardGestureArea</code> with <code>offset</code> on iOS \ud83d\udd25",id:"keyboardgesturearea-with-offset-on-ios-",level:2}];function c(e){const o={admonition:"admonition",code:"code",h2:"h2",h3:"h3",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(o.p,{children:["Today I'm glad to announce a new ",(0,s.jsx)(o.code,{children:"1.15.0"})," version of ",(0,s.jsx)(o.code,{children:"react-native-keyboard-controller"})," \ud83c\udf89"]}),"\n",(0,s.jsx)(o.p,{children:"This release mainly focuses on various ways to dismiss a keyboard, so let's go and see which new features this release brings \ud83d\udc47"}),"\n",(0,s.jsxs)(o.h2,{id:"changes-to-dismiss-method",children:["Changes to ",(0,s.jsx)(o.code,{children:".dismiss()"})," method"]}),"\n",(0,s.jsxs)(o.h3,{id:"dismiss-method-now-returns-a-promise",children:[(0,s.jsx)(o.code,{children:"dismiss()"})," method now returns a promise"]}),"\n",(0,s.jsxs)(o.p,{children:["Previously, the ",(0,s.jsx)(o.code,{children:"dismiss()"})," method was synchronous, which meant that you couldn't determine the moment when keyboard is fully hidden. Typically many people were using one time listener that was resolving a promise or executing the code that had to be executed after keyboard dismissal. The code could look like this:"]}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{className:"language-tsx",children:'import {\n  KeyboardController,\n  KeyboardEvents,\n} from "react-native-keyboard-controller";\n\nconst subscription = KeyboardEvents.addListener("keyboardDidHide", () => {\n  setVisible(true);\n  subscription.remove();\n});\n\nKeyboardController.dismiss();\n'})}),"\n",(0,s.jsxs)(o.p,{children:["Now, ",(0,s.jsx)(o.code,{children:".dismiss()"})," returns a promise, so you can use it in ",(0,s.jsx)(o.code,{children:"async"})," way:"]}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{className:"language-ts",children:'import { KeyboardController } from "react-native-keyboard-controller";\n\nawait KeyboardController.dismiss();\nsetVisible(true);\n'})}),"\n",(0,s.jsx)(o.p,{children:"Much cleaner and more readable code! \ud83d\udcaa"}),"\n",(0,s.jsxs)(o.h3,{id:"dismiss-now-blurs-input-by-default",children:[(0,s.jsx)(o.code,{children:"dismiss()"})," now blurs input by default"]}),"\n",(0,s.jsxs)(o.p,{children:["The previous behavior of ",(0,s.jsx)(o.code,{children:"dismiss()"})," was keeping the focus on the input on Android and was blurring the input on iOS. This behavior was not very intuitive and such inconsistency could causing a lot of issues. Now, the default behavior is to blur the input on both platforms \ud83d\ude0e"]}),"\n",(0,s.jsx)(o.p,{children:"Though a rhetorical question might be raised - I like the old behavior, when input still hold the focus \ud83e\udd37\u200d\u2642\ufe0f We hear you! \ud83d\udc47"}),"\n",(0,s.jsxs)(o.h3,{id:"dismiss-now-accepts-a-keepfocus-parameter",children:[(0,s.jsx)(o.code,{children:"dismiss()"})," now accepts a ",(0,s.jsx)(o.code,{children:"keepFocus"})," parameter"]}),"\n",(0,s.jsxs)(o.p,{children:["Sometimes you might want to keep the focus on the input, even after keyboard is dismissed. This way users can understand which field was focused the last. If you want to achieve this behavior, you can pass ",(0,s.jsx)(o.code,{children:"keepFocus"})," parameter to ",(0,s.jsx)(o.code,{children:"dismiss()"})," method:"]}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{className:"language-ts",children:"KeyboardController.dismiss({ keepFocus: true });\n"})}),"\n",(0,s.jsxs)(o.h2,{id:"new-keyboardcontroller-api-methods",children:["New ",(0,s.jsx)(o.code,{children:"KeyboardController"})," API methods"]}),"\n",(0,s.jsx)(o.p,{children:"We finished with dismissal part, but the counter part of dismissal is checking current keyboard state. This release is packed with 2 new methods that aims to simplify the keyboard state checks \ud83d\ude0a"}),"\n",(0,s.jsxs)(o.h3,{id:"new-isvisible-method",children:["New ",(0,s.jsx)(o.code,{children:".isVisible()"})," method"]}),"\n",(0,s.jsxs)(o.h3,{id:"new-state-method",children:["New ",(0,s.jsx)(o.code,{children:".state()"})," method"]}),"\n",(0,s.jsxs)(o.h2,{id:"better-keyboardstickyview-and-keyboardtoolbar-interoperability",children:["Better ",(0,s.jsx)(o.code,{children:"KeyboardStickyView"})," and ",(0,s.jsx)(o.code,{children:"KeyboardToolbar"})," interoperability"]}),"\n",(0,s.jsxs)(o.h3,{id:"keyboardtoolbar-now-accepts-keyboardstickyview-props",children:[(0,s.jsx)(o.code,{children:"KeyboardToolbar"})," now accepts ",(0,s.jsx)(o.code,{children:"KeyboardStickyView"})," props"]}),"\n",(0,s.jsxs)(o.h3,{id:"keyboardstickyview-got-new-enabled-prop",children:[(0,s.jsx)(o.code,{children:"KeyboardStickyView"})," got new ",(0,s.jsx)(o.code,{children:"enabled"})," prop"]}),"\n",(0,s.jsxs)(o.h2,{id:"keyboardevents-metadata-enhancements",children:[(0,s.jsx)(o.code,{children:"KeyboardEvents"})," metadata enhancements"]}),"\n",(0,s.jsxs)(o.h3,{id:"new-type-property",children:["New ",(0,s.jsx)(o.code,{children:"type"})," property"]}),"\n",(0,s.jsxs)(o.h3,{id:"new-appearance-property",children:["New ",(0,s.jsx)(o.code,{children:"appearance"})," property"]}),"\n",(0,s.jsxs)(o.h2,{id:"keyboardgesturearea-with-offset-on-ios-",children:[(0,s.jsx)(o.code,{children:"KeyboardGestureArea"})," with ",(0,s.jsx)(o.code,{children:"offset"})," on iOS \ud83d\udd25"]}),"\n",(0,s.jsxs)(o.p,{children:["The cherry on the cake of this release is making ",(0,s.jsx)(o.code,{children:"KeyboardGestureArea"})," available on iOS \ud83c\udf52"]}),"\n",(0,s.jsxs)(o.p,{children:["This component got new property ",(0,s.jsx)(o.code,{children:"textInputNativeID"})," which is available on iOS only and ",(0,s.jsx)(o.code,{children:"offset"})," property is cross-platform now."]}),"\n",(0,s.jsxs)(o.admonition,{type:"tip",children:[(0,s.jsxs)(o.mdxAdmonitionTitle,{children:["Why ",(0,s.jsx)(o.code,{children:"textInputNativeID"})," was added?"]}),(0,s.jsx)(o.p,{children:"Short answer - to keep a release backward compatible."}),(0,s.jsxs)(o.p,{children:["Long answer - before on iOS ",(0,s.jsx)(o.code,{children:"KeyboardGestureArea"})," was returning ",(0,s.jsx)(o.code,{children:"React.Fragment"}),". I think some people were relying on this fact, that ",(0,s.jsx)(o.code,{children:"KeyboardGestureArea"})," doesn't do anything on iOS, so if this component starts to change a behavior instantly it may produce a hard migration. So to avoid this I added a new property ",(0,s.jsx)(o.code,{children:"textInputNativeID"})," which acts as a switch (unless it's specified ",(0,s.jsx)(o.code,{children:"KeyboardGestureArea"})," will not do anything useful on iOS). Also this property allows to selectively add offset for given inputs."]})]})]})}function h(e={}){const{wrapper:o}={...(0,r.R)(),...e.components};return o?(0,s.jsx)(o,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,o,i)=>{i.d(o,{R:()=>n,x:()=>a});var s=i(96540);const r={},t=s.createContext(r);function n(e){const o=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function a(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:n(e.components),s.createElement(t.Provider,{value:o},e.children)}}}]);
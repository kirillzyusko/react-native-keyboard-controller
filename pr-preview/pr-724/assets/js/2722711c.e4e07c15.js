"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2202],{24237:(e,s,o)=>{o.r(s),o.d(s,{assets:()=>d,contentTitle:()=>n,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>c});var i=o(74848),r=o(28453);const t={slug:"mastering-keyboard-dismissal",title:"Mastering keyboard dismissal \ud83e\udd77\ud83c\udffc",authors:["kirill"],tags:["react-native","keyboard","dismiss","state","isVisible"],keywords:["react-native-keyboard-controller","keyboard","dismiss","state","isVisible"]},n=void 0,a={permalink:"/react-native-keyboard-controller/pr-preview/pr-724/blog/mastering-keyboard-dismissal",editUrl:"https://github.com/kirillzyusko/react-native-keyboard-controller/tree/main/docs/blog/2024-12-31-release-1-15/index.mdx",source:"@site/blog/2024-12-31-release-1-15/index.mdx",title:"Mastering keyboard dismissal \ud83e\udd77\ud83c\udffc",description:"Today I'm glad to announce a new 1.15.0 version of react-native-keyboard-controller \ud83c\udf89",date:"2024-12-31T00:00:00.000Z",tags:[{inline:!0,label:"react-native",permalink:"/react-native-keyboard-controller/pr-preview/pr-724/blog/tags/react-native"},{inline:!0,label:"keyboard",permalink:"/react-native-keyboard-controller/pr-preview/pr-724/blog/tags/keyboard"},{inline:!0,label:"dismiss",permalink:"/react-native-keyboard-controller/pr-preview/pr-724/blog/tags/dismiss"},{inline:!0,label:"state",permalink:"/react-native-keyboard-controller/pr-preview/pr-724/blog/tags/state"},{inline:!0,label:"isVisible",permalink:"/react-native-keyboard-controller/pr-preview/pr-724/blog/tags/is-visible"}],readingTime:3.25,hasTruncateMarker:!0,authors:[{name:"Kirill Zyusko",title:"Library author",url:"https://github.com/kirillzyusko",imageURL:"https://github.com/kirillzyusko.png",key:"kirill"}],frontMatter:{slug:"mastering-keyboard-dismissal",title:"Mastering keyboard dismissal \ud83e\udd77\ud83c\udffc",authors:["kirill"],tags:["react-native","keyboard","dismiss","state","isVisible"],keywords:["react-native-keyboard-controller","keyboard","dismiss","state","isVisible"]},unlisted:!1,nextItem:{title:"New OverKeyboardView component",permalink:"/react-native-keyboard-controller/pr-preview/pr-724/blog/over-keyboard-view"}},d={authorsImageUrls:[void 0]},c=[{value:"Changes to <code>dismiss</code> method",id:"changes-to-dismiss-method",level:2},{value:"<code>dismiss</code> method now returns a promise",id:"dismiss-method-now-returns-a-promise",level:3},{value:"<code>dismiss</code> now blurs input by default",id:"dismiss-now-blurs-input-by-default",level:3},{value:"<code>dismiss</code> now accepts a <code>keepFocus</code> parameter",id:"dismiss-now-accepts-a-keepfocus-parameter",level:3},{value:"New <code>KeyboardController</code> API methods",id:"new-keyboardcontroller-api-methods",level:2},{value:"New <code>isVisible</code> method",id:"new-isvisible-method",level:3},{value:"New <code>.state()</code> method",id:"new-state-method",level:3},{value:"Better <code>KeyboardStickyView</code> and <code>KeyboardToolbar</code> interoperability",id:"better-keyboardstickyview-and-keyboardtoolbar-interoperability",level:2},{value:"<code>KeyboardToolbar</code> now accepts <code>KeyboardStickyView</code> props",id:"keyboardtoolbar-now-accepts-keyboardstickyview-props",level:3},{value:"<code>KeyboardStickyView</code> got new <code>enabled</code> prop",id:"keyboardstickyview-got-new-enabled-prop",level:3},{value:"<code>KeyboardEvents</code> metadata enhancements",id:"keyboardevents-metadata-enhancements",level:2},{value:"New <code>type</code> property",id:"new-type-property",level:3},{value:"New <code>appearance</code> property",id:"new-appearance-property",level:3},{value:"<code>KeyboardGestureArea</code> with <code>offset</code> on iOS \ud83d\udd25",id:"keyboardgesturearea-with-offset-on-ios-",level:2}];function l(e){const s={admonition:"admonition",code:"code",h2:"h2",h3:"h3",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(s.p,{children:["Today I'm glad to announce a new ",(0,i.jsx)(s.code,{children:"1.15.0"})," version of ",(0,i.jsx)(s.code,{children:"react-native-keyboard-controller"})," \ud83c\udf89"]}),"\n",(0,i.jsx)(s.p,{children:"This release mainly focuses on various ways to dismiss a keyboard and API enhancements, so let's go and see which new features this release brings \ud83d\udc47"}),"\n",(0,i.jsxs)(s.h2,{id:"changes-to-dismiss-method",children:["Changes to ",(0,i.jsx)(s.code,{children:"dismiss"})," method"]}),"\n",(0,i.jsxs)(s.h3,{id:"dismiss-method-now-returns-a-promise",children:[(0,i.jsx)(s.code,{children:"dismiss"})," method now returns a promise"]}),"\n",(0,i.jsxs)(s.p,{children:["Previously, the ",(0,i.jsx)(s.code,{children:"dismiss"})," method was synchronous, which meant that you couldn't determine the moment when keyboard is fully hidden. Typically many developers were using one time listener that was resolving a promise or executing the code that had to be executed after keyboard dismissal. The code could look like this:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-tsx",children:'import {\n  KeyboardController,\n  KeyboardEvents,\n} from "react-native-keyboard-controller";\n\nconst subscription = KeyboardEvents.addListener("keyboardDidHide", () => {\n  setVisible(true);\n  subscription.remove();\n});\n\nKeyboardController.dismiss();\n'})}),"\n",(0,i.jsxs)(s.p,{children:["Now, ",(0,i.jsx)(s.code,{children:"dismiss"})," returns a promise, so you can use it in ",(0,i.jsx)(s.code,{children:"async"})," way:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-ts",children:'import { KeyboardController } from "react-native-keyboard-controller";\n\nawait KeyboardController.dismiss();\nsetVisible(true);\n'})}),"\n",(0,i.jsx)(s.p,{children:"Much cleaner and more readable code! \ud83d\udcaa"}),"\n",(0,i.jsxs)(s.h3,{id:"dismiss-now-blurs-input-by-default",children:[(0,i.jsx)(s.code,{children:"dismiss"})," now blurs input by default"]}),"\n",(0,i.jsxs)(s.p,{children:["The previous behavior of ",(0,i.jsx)(s.code,{children:"dismiss"})," was keeping the focus on the input on Android and was blurring the input on iOS. This behavior was not very intuitive and such inconsistency could causing a lot of issues. Now, the default behavior is to blur the input on both platforms \ud83d\ude0e"]}),"\n",(0,i.jsx)(s.p,{children:"Though a rhetorical question might be raised - I like the old behavior, when input still hold the focus \ud83e\udd37\u200d\u2642\ufe0f We hear you! \ud83d\udc47"}),"\n",(0,i.jsxs)(s.h3,{id:"dismiss-now-accepts-a-keepfocus-parameter",children:[(0,i.jsx)(s.code,{children:"dismiss"})," now accepts a ",(0,i.jsx)(s.code,{children:"keepFocus"})," parameter"]}),"\n",(0,i.jsxs)(s.p,{children:["Sometimes you might want to keep the focus on the input, even after keyboard is dismissed. This way users can understand which field was focused the last. If you want to achieve this behavior, you can pass ",(0,i.jsx)(s.code,{children:"keepFocus"})," parameter to ",(0,i.jsx)(s.code,{children:"dismiss"})," method:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-ts",children:"KeyboardController.dismiss({ keepFocus: true });\n"})}),"\n",(0,i.jsxs)(s.h2,{id:"new-keyboardcontroller-api-methods",children:["New ",(0,i.jsx)(s.code,{children:"KeyboardController"})," API methods"]}),"\n",(0,i.jsxs)(s.p,{children:["We finished with dismissal part. But the counter part of dismissal is the checking current keyboard state. This release is packed with 2 new methods that aims to simplify the keyboard state checks and achieve a parity with ",(0,i.jsx)(s.code,{children:"react-native"})," API \ud83d\ude0a"]}),"\n",(0,i.jsxs)(s.h3,{id:"new-isvisible-method",children:["New ",(0,i.jsx)(s.code,{children:"isVisible"})," method"]}),"\n",(0,i.jsxs)(s.p,{children:["This method acts as a ",(0,i.jsx)(s.code,{children:"Keyboard.isVisible()"})," method from ",(0,i.jsx)(s.code,{children:"react-native"})," and returns ",(0,i.jsx)(s.code,{children:"true"})," if keyboard is currently visible and ",(0,i.jsx)(s.code,{children:"false"})," otherwise."]}),"\n",(0,i.jsx)(s.p,{children:"You can use it to check keyboard visibility on demand without a need to create listeners."}),"\n",(0,i.jsxs)(s.h3,{id:"new-state-method",children:["New ",(0,i.jsx)(s.code,{children:".state()"})," method"]}),"\n",(0,i.jsxs)(s.p,{children:["The new method returns the last keyboard state. It returns ",(0,i.jsx)(s.code,{children:"null"})," if keyboard was not shown in the app yet."]}),"\n",(0,i.jsxs)(s.p,{children:["This method acts similar to ",(0,i.jsx)(s.code,{children:"Keyboard.metrics()"})," from ",(0,i.jsx)(s.code,{children:"react-native"})," and returns the current keyboard state. The reason why it is named ",(0,i.jsx)(s.code,{children:"state"})," instead of ",(0,i.jsx)(s.code,{children:"metrics"})," is because it returns a different data structure and it's not a drop-in replacement for ",(0,i.jsx)(s.code,{children:"Keyboard.metrics()"}),". However you can achieve the same results using ",(0,i.jsx)(s.code,{children:"KeyboardController.state()"})," (because it gives an access to ",(0,i.jsx)(s.code,{children:"height"})," value) and even more - you can other properties, such as ",(0,i.jsx)(s.code,{children:"type"}),", ",(0,i.jsx)(s.code,{children:"appearance"}),", ",(0,i.jsx)(s.code,{children:"target"}),", ",(0,i.jsx)(s.code,{children:"timestamp"})," and others to get more information about the keyboard."]}),"\n",(0,i.jsxs)(s.h2,{id:"better-keyboardstickyview-and-keyboardtoolbar-interoperability",children:["Better ",(0,i.jsx)(s.code,{children:"KeyboardStickyView"})," and ",(0,i.jsx)(s.code,{children:"KeyboardToolbar"})," interoperability"]}),"\n",(0,i.jsxs)(s.h3,{id:"keyboardtoolbar-now-accepts-keyboardstickyview-props",children:[(0,i.jsx)(s.code,{children:"KeyboardToolbar"})," now accepts ",(0,i.jsx)(s.code,{children:"KeyboardStickyView"})," props"]}),"\n",(0,i.jsxs)(s.h3,{id:"keyboardstickyview-got-new-enabled-prop",children:[(0,i.jsx)(s.code,{children:"KeyboardStickyView"})," got new ",(0,i.jsx)(s.code,{children:"enabled"})," prop"]}),"\n",(0,i.jsxs)(s.h2,{id:"keyboardevents-metadata-enhancements",children:[(0,i.jsx)(s.code,{children:"KeyboardEvents"})," metadata enhancements"]}),"\n",(0,i.jsxs)(s.p,{children:["This release enhances ",(0,i.jsx)(s.code,{children:"KeyboardEventData"})," with new properties."]}),"\n",(0,i.jsxs)(s.h3,{id:"new-type-property",children:["New ",(0,i.jsx)(s.code,{children:"type"})," property"]}),"\n",(0,i.jsxs)(s.h3,{id:"new-appearance-property",children:["New ",(0,i.jsx)(s.code,{children:"appearance"})," property"]}),"\n",(0,i.jsxs)(s.h2,{id:"keyboardgesturearea-with-offset-on-ios-",children:[(0,i.jsx)(s.code,{children:"KeyboardGestureArea"})," with ",(0,i.jsx)(s.code,{children:"offset"})," on iOS \ud83d\udd25"]}),"\n",(0,i.jsxs)(s.p,{children:["The cherry on the cake of this release is making ",(0,i.jsx)(s.code,{children:"KeyboardGestureArea"})," available on iOS \ud83c\udf52"]}),"\n",(0,i.jsxs)(s.p,{children:["This component got new property ",(0,i.jsx)(s.code,{children:"textInputNativeID"})," which is available on iOS only and ",(0,i.jsx)(s.code,{children:"offset"})," property is cross-platform now."]}),"\n",(0,i.jsxs)(s.admonition,{type:"tip",children:[(0,i.jsxs)(s.mdxAdmonitionTitle,{children:["Why ",(0,i.jsx)(s.code,{children:"textInputNativeID"})," was added?"]}),(0,i.jsx)(s.p,{children:"Short answer - to keep a release backward compatible."}),(0,i.jsxs)(s.p,{children:["Long answer - before on iOS ",(0,i.jsx)(s.code,{children:"KeyboardGestureArea"})," was returning ",(0,i.jsx)(s.code,{children:"React.Fragment"}),". I think some developers were relying on this fact, that ",(0,i.jsx)(s.code,{children:"KeyboardGestureArea"})," doesn't do anything on iOS, so if this component starts to change a behavior instantly it may produce a hard migration. So to avoid this I added a new property ",(0,i.jsx)(s.code,{children:"textInputNativeID"})," which acts as a switch (unless it's specified ",(0,i.jsx)(s.code,{children:"KeyboardGestureArea"})," will not do anything useful on iOS). Also this property allows to selectively add offset for given inputs."]})]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,s,o)=>{o.d(s,{R:()=>n,x:()=>a});var i=o(96540);const r={},t=i.createContext(r);function n(e){const s=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:n(e.components),i.createElement(t.Provider,{value:s},e.children)}}}]);
"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[81335],{28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var r=n(96540);const i={},s=r.createContext(i);function o(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:t},e.children)}},69026:(e,t,n)=>{n.d(t,{A:()=>s});var r=n(86025),i=(n(96540),n(74848));function s({src:e,width:t=100,...n}){const s=(0,r.Ay)(e);return(0,i.jsx)("div",{className:"center video",children:(0,i.jsx)("video",{autoPlay:!0,loop:!0,muted:!0,playsInline:!0,height:"100%",src:s,width:`${t}%`,...n})})}},88460:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var r=n(74848),i=n(28453),s=n(69026);const o={sidebar_position:5,description:"A guide that explores the challenges of building chat app layouts and shows how to solve them using the KeyboardChatScrollView component",keywords:["react-native-keyboard-controller","react-native","keyboard","chat","KeyboardChatScrollView"]},a="Building a chat app",l={id:"guides/building-chat-app",title:"Building a chat app",description:"A guide that explores the challenges of building chat app layouts and shows how to solve them using the KeyboardChatScrollView component",source:"@site/docs/guides/building-chat-app.mdx",sourceDirName:"guides",slug:"/guides/building-chat-app",permalink:"/react-native-keyboard-controller/pr-preview/pr-1322/docs/next/guides/building-chat-app",draft:!1,unlisted:!1,editUrl:"https://github.com/kirillzyusko/react-native-keyboard-controller/tree/main/docs/docs/guides/building-chat-app.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,description:"A guide that explores the challenges of building chat app layouts and shows how to solve them using the KeyboardChatScrollView component",keywords:["react-native-keyboard-controller","react-native","keyboard","chat","KeyboardChatScrollView"]},sidebar:"tutorialSidebar",previous:{title:"Components Overview",permalink:"/react-native-keyboard-controller/pr-preview/pr-1322/docs/next/guides/components-overview"},next:{title:"Compatibility",permalink:"/react-native-keyboard-controller/pr-preview/pr-1322/docs/next/guides/compatibility"}},c={},d=[{value:"Why general-purpose components fall short",id:"why-general-purpose-components-fall-short",level:2},{value:"What chat apps actually need",id:"what-chat-apps-actually-need",level:2},{value:"What is <code>KeyboardChatScrollView</code>?",id:"what-is-keyboardchatscrollview",level:2},{value:"Step-by-step integration",id:"step-by-step-integration",level:2},{value:"Basic setup with <code>ScrollView</code>",id:"basic-setup-with-scrollview",level:3},{value:"Adding interactive dismissal",id:"adding-interactive-dismissal",level:3},{value:"Accounting for bottom safe area",id:"accounting-for-bottom-safe-area",level:3},{value:"Choosing a <code>keyboardLiftBehavior</code>",id:"choosing-a-keyboardliftbehavior",level:3},{value:"Freezing content for custom input views",id:"freezing-content-for-custom-input-views",level:3},{value:"Using with virtualized lists",id:"using-with-virtualized-lists",level:2},{value:"Creating a scroll wrapper",id:"creating-a-scroll-wrapper",level:3},{value:"Plugging into <code>FlashList</code>",id:"plugging-into-flashlist",level:3},{value:"Plugging into <code>FlatList</code> / <code>LegendList</code>",id:"plugging-into-flatlist--legendlist",level:3},{value:"Handling the <code>inverted</code> prop",id:"handling-the-inverted-prop",level:3},{value:"Complete example",id:"complete-example",level:2},{value:"API reference",id:"api-reference",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components},{Head:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Head",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"building-a-chat-app",children:"Building a chat app"}),"\n",(0,r.jsx)(t.p,{children:"Keyboard handling in chat applications has always been one of the trickiest problems in mobile development \u2014 even on native platforms. Chat apps push keyboard interactions to their limits: interactive dismissal, content repositioning, smooth transitions between the keyboard and custom input views, and all of it at 120 FPS. Getting this right requires deep integration between the keyboard, scroll views, and layout systems \u2014 far more than a general-purpose component can offer."}),"\n","\n",(0,r.jsx)(s.A,{src:"/video/keyboard-chat-scroll-view/always.mov",style:{height:"40vh",marginBottom:20}}),"\n",(0,r.jsx)(t.h2,{id:"why-general-purpose-components-fall-short",children:"Why general-purpose components fall short"}),"\n",(0,r.jsxs)(t.p,{children:["You might be tempted to reach for ",(0,r.jsx)(t.code,{children:"KeyboardAvoidingView"})," or ",(0,r.jsx)(t.code,{children:"KeyboardAwareScrollView"})," to handle keyboard interactions in a chat app. While these components work well for forms, settings screens, and other straightforward layouts, they weren't designed for the unique demands of a chat interface."]}),"\n",(0,r.jsx)(t.p,{children:"Here's what you'll run into:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Frame drops with complex layouts"})," \u2014 ",(0,r.jsx)(t.code,{children:"KeyboardAvoidingView"})," with ",(0,r.jsx)(t.code,{children:'behavior="padding"'})," or ",(0,r.jsx)(t.code,{children:'behavior="height"'})," can cause ",(0,r.jsx)(t.a,{href:"https://github.com/software-mansion/react-native-reanimated/issues/6854",children:"frame drops"}),", particularly when the layout is complex."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"First-message rendering issues"})," \u2014 using ",(0,r.jsx)(t.code,{children:'behavior="translate-with-padding"'})," makes it ",(0,r.jsx)(t.a,{href:"https://github.com/kirillzyusko/react-native-keyboard-controller/issues/951",children:"impossible"})," to render the first message at the top of the screen."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Double scroll on interactive dismissal"})," \u2014 combining ",(0,r.jsx)(t.code,{children:"KeyboardAvoidingView"})," with interactive keyboard dismissal on iOS leads to a ",(0,r.jsx)(t.a,{href:"https://github.com/kirillzyusko/react-native-keyboard-controller/issues/594#issuecomment-2406860730",children:"double-scroll problem"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Unnecessary animation"})," \u2014 when you are at the beginning of the list and keyboard closes, ",(0,r.jsx)(t.code,{children:"KeyboardAvoidingView"})," still animates the content even though no scrolling adjustment is needed."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"These aren't edge cases \u2014 they're fundamental mismatches between what generic components were designed to do and what chat apps actually need. You can work around them, but you'll end up writing a lot of platform-specific code to get a polished result."}),"\n",(0,r.jsx)(t.h2,{id:"what-chat-apps-actually-need",children:"What chat apps actually need"}),"\n",(0,r.jsx)(t.p,{children:"Despite the complexity, most chat apps share the same set of keyboard-related requirements:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Content repositioning"})," \u2014 push messages up when the keyboard appears (with the option to disable this in certain cases)."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Interactive dismissal"})," \u2014 let users swipe the keyboard away with a drag gesture."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Content freezing"})," \u2014 hold the chat in place when switching from the keyboard to a custom input view like an emoji picker or bottom sheet."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Virtualized list support"})," \u2014 work seamlessly with ",(0,r.jsx)(t.code,{children:"FlatList"}),", ",(0,r.jsx)(t.code,{children:"FlashList"}),", ",(0,r.jsx)(t.code,{children:"LegendList"}),", and other virtualized list implementations."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Smooth animations"})," \u2014 maintain 60/120 FPS during keyboard transitions, even on low-end devices."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Keyboard padding"})," \u2014 extend the scrollable area to account for keyboard height."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Custom offsets"})," \u2014 support layouts where the chat isn't flush against the bottom of the screen."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["Implementing all of this from scratch is a significant undertaking. That's why we built ",(0,r.jsx)(t.code,{children:"KeyboardChatScrollView"})," \u2014 a dedicated component that handles all of these behaviors out of the box, so you can focus on building your chat experience rather than fighting the keyboard."]}),"\n",(0,r.jsxs)(t.h2,{id:"what-is-keyboardchatscrollview",children:["What is ",(0,r.jsx)(t.code,{children:"KeyboardChatScrollView"}),"?"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"KeyboardChatScrollView"})," is a purpose-built component for chat app layouts. It provides all the requirements listed above \u2014 content repositioning, interactive dismissal, content freezing, virtualized list support, smooth animations, keyboard padding, and custom offsets \u2014 with zero configuration needed for the common case."]}),"\n",(0,r.jsx)(t.h2,{id:"step-by-step-integration",children:"Step-by-step integration"}),"\n",(0,r.jsxs)(t.p,{children:["This section walks through building a chat screen from scratch using ",(0,r.jsx)(t.code,{children:"KeyboardChatScrollView"}),". We'll start with the simplest possible setup and progressively layer on features."]}),"\n",(0,r.jsxs)(t.h3,{id:"basic-setup-with-scrollview",children:["Basic setup with ",(0,r.jsx)(t.code,{children:"ScrollView"})]}),"\n",(0,r.jsxs)(t.p,{children:["The simplest way to use ",(0,r.jsx)(t.code,{children:"KeyboardChatScrollView"})," is as a drop-in replacement for ",(0,r.jsx)(t.code,{children:"ScrollView"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'import { TextInput, View } from "react-native";\nimport {\n  KeyboardChatScrollView,\n  KeyboardStickyView,\n} from "react-native-keyboard-controller";\n\nfunction ChatScreen() {\n  return (\n    <View style={{ flex: 1 }}>\n      <KeyboardChatScrollView>\n        {messages.map((msg) => (\n          <Message key={msg.id} {...msg} />\n        ))}\n      </KeyboardChatScrollView>\n      <KeyboardStickyView>\n        <TextInput placeholder="Type a message..." />\n      </KeyboardStickyView>\n    </View>\n  );\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:"That's it \u2014 the keyboard will push messages up when it appears, and pull them back when it hides."}),"\n",(0,r.jsx)(t.h3,{id:"adding-interactive-dismissal",children:"Adding interactive dismissal"}),"\n",(0,r.jsxs)(t.p,{children:["To let users swipe the keyboard away with a drag gesture, wrap the chat area in a ",(0,r.jsx)(t.code,{children:"KeyboardGestureArea"})," and set ",(0,r.jsx)(t.code,{children:'keyboardDismissMode="interactive"'})," on the scroll view:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'import { TextInput, View } from "react-native";\nimport {\n  KeyboardChatScrollView,\n  KeyboardGestureArea,\n  KeyboardStickyView,\n} from "react-native-keyboard-controller";\n\nfunction ChatScreen() {\n  return (\n    <View style={{ flex: 1 }}>\n      // add-new-code\n      <KeyboardGestureArea\n        // add-new-code\n        interpolator="ios"\n        // add-new-code\n        style={{ flex: 1 }}\n        // add-new-code\n        textInputNativeID="chat-input"\n        // add-new-code\n      >\n        <KeyboardChatScrollView\n          // add-new-code\n          keyboardDismissMode="interactive"\n        >\n          {messages.map((msg) => (\n            <Message key={msg.id} {...msg} />\n          ))}\n        </KeyboardChatScrollView>\n        <KeyboardStickyView>\n          // add-new-code\n          <TextInput nativeID="chat-input" placeholder="Type a message..." />\n        </KeyboardStickyView>\n      </KeyboardGestureArea>\n    </View>\n  );\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Note the matching ",(0,r.jsx)(t.code,{children:"textInputNativeID"})," on ",(0,r.jsx)(t.code,{children:"KeyboardGestureArea"})," and ",(0,r.jsx)(t.code,{children:"nativeID"})," on ",(0,r.jsx)(t.code,{children:"TextInput"})," \u2014 this links the gesture area to the correct input."]}),"\n",(0,r.jsx)(t.h3,{id:"accounting-for-bottom-safe-area",children:"Accounting for bottom safe area"}),"\n",(0,r.jsxs)(t.p,{children:["If your chat sits above the bottom safe area (or a tab bar), set the ",(0,r.jsx)(t.code,{children:"offset"})," prop so the component only pushes content by the effective distance (",(0,r.jsx)(t.code,{children:"keyboardHeight - offset"}),"):"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'import { useSafeAreaInsets } from "react-native-safe-area-context";\n\nfunction ChatScreen() {\n  const { bottom } = useSafeAreaInsets();\n\n  return (\n    <KeyboardChatScrollView offset={bottom}>\n      {/* ...messages... */}\n    </KeyboardChatScrollView>\n  );\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:"Without this, the content would overshoot by the height of the safe area every time the keyboard appears."}),"\n",(0,r.jsxs)(t.h3,{id:"choosing-a-keyboardliftbehavior",children:["Choosing a ",(0,r.jsx)(t.code,{children:"keyboardLiftBehavior"})]}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"keyboardLiftBehavior"})," prop controls how messages react when the keyboard opens. Different chat apps use different strategies \u2014 pick the one that fits your product:"]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Value"}),(0,r.jsx)(t.th,{children:"Behavior"}),(0,r.jsx)(t.th,{children:"Used by"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.code,{children:'"always"'})," (default)"]}),(0,r.jsx)(t.td,{children:"Content always lifts with the keyboard"}),(0,r.jsx)(t.td,{children:"Telegram, WhatsApp"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:'"whenAtEnd"'})}),(0,r.jsx)(t.td,{children:"Content lifts only if the user is scrolled to the bottom"}),(0,r.jsx)(t.td,{children:"ChatGPT"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:'"persistent"'})}),(0,r.jsx)(t.td,{children:"Content lifts when keyboard opens, but stays when it hides"}),(0,r.jsx)(t.td,{children:"Claude"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:'"never"'})}),(0,r.jsx)(t.td,{children:"Content never moves; the keyboard overlaps the chat"}),(0,r.jsx)(t.td,{children:"Perplexity"})]})]})]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'<KeyboardChatScrollView keyboardLiftBehavior="whenAtEnd">\n  {/* ...messages... */}\n</KeyboardChatScrollView>\n'})}),"\n",(0,r.jsx)(t.h3,{id:"freezing-content-for-custom-input-views",children:"Freezing content for custom input views"}),"\n",(0,r.jsxs)(t.p,{children:["When transitioning from the keyboard to a custom input view (like an emoji picker), you don't want the chat to jump. Set ",(0,r.jsx)(t.code,{children:"freeze={true}"})," to hold the scroll position in place during the transition:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:"const [showEmojiPicker, setShowEmojiPicker] = useState(false);\nconst [freeze, setFreeze] = useState(false);\n\nconst onEmojiPress = () => {\n  setFreeze(true); // freeze before dismissing keyboard\n  Keyboard.dismiss();\n  setShowEmojiPicker(true);\n};\n\nconst onKeyboardPress = () => {\n  setFreeze(false);\n  setShowEmojiPicker(false);\n  textInputRef.current?.focus();\n};\n\n// ...\n\n<KeyboardChatScrollView freeze={freeze}>\n  {/* ...messages... */}\n</KeyboardChatScrollView>;\n"})}),"\n",(0,r.jsxs)(t.p,{children:["When ",(0,r.jsx)(t.code,{children:"freeze"})," is ",(0,r.jsx)(t.code,{children:"true"}),", all keyboard-driven layout changes (padding, content offset, scroll position) are paused."]}),"\n",(0,r.jsx)(t.h2,{id:"using-with-virtualized-lists",children:"Using with virtualized lists"}),"\n",(0,r.jsxs)(t.p,{children:["For production chat apps you'll likely use a virtualized list (",(0,r.jsx)(t.code,{children:"FlatList"}),", ",(0,r.jsx)(t.code,{children:"FlashList"}),", or ",(0,r.jsx)(t.code,{children:"LegendList"}),") instead of a plain ",(0,r.jsx)(t.code,{children:"ScrollView"}),". All of these accept a custom scroll component, making integration straightforward."]}),"\n",(0,r.jsx)(t.h3,{id:"creating-a-scroll-wrapper",children:"Creating a scroll wrapper"}),"\n",(0,r.jsxs)(t.p,{children:["Create a wrapper that passes ",(0,r.jsx)(t.code,{children:"KeyboardChatScrollView"})," props down:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",metastring:'title="VirtualizedListScrollView.tsx"',children:'import React, { forwardRef } from "react";\nimport { KeyboardChatScrollView } from "react-native-keyboard-controller";\nimport { useSafeAreaInsets } from "react-native-safe-area-context";\n\nimport type { ScrollViewProps } from "react-native";\nimport type { KeyboardChatScrollViewProps } from "react-native-keyboard-controller";\n\ntype Ref = React.ElementRef<typeof KeyboardChatScrollView>;\n\nconst BOTTOM_OFFSET = 8; // distance from safe area to input\n\nconst VirtualizedListScrollView = forwardRef<\n  Ref,\n  ScrollViewProps & KeyboardChatScrollViewProps\n>((props, ref) => {\n  const { bottom } = useSafeAreaInsets();\n\n  return (\n    <KeyboardChatScrollView\n      ref={ref}\n      automaticallyAdjustContentInsets={false}\n      contentInsetAdjustmentBehavior="never"\n      keyboardDismissMode="interactive"\n      offset={bottom - BOTTOM_OFFSET}\n      {...props}\n    />\n  );\n});\n\nexport default VirtualizedListScrollView;\n'})}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["Always set ",(0,r.jsx)(t.code,{children:"automaticallyAdjustContentInsets={false}"})," and ",(0,r.jsx)(t.code,{children:'contentInsetAdjustmentBehavior="never"'})," when using ",(0,r.jsx)(t.code,{children:"KeyboardChatScrollView"})," inside virtualized lists. This prevents iOS from applying its own content inset adjustments, which would conflict with the component's inset management."]})}),"\n",(0,r.jsxs)(t.h3,{id:"plugging-into-flashlist",children:["Plugging into ",(0,r.jsx)(t.code,{children:"FlashList"})]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"FlashList"})," accepts ",(0,r.jsx)(t.code,{children:"renderScrollComponent"})," directly as a component reference:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'import { FlashList } from "@shopify/flash-list";\n\n<FlashList\n  data={messages}\n  inverted\n  keyExtractor={(item) => item.id}\n  renderItem={({ item }) => <Message {...item} />}\n  renderScrollComponent={VirtualizedListScrollView}\n/>;\n'})}),"\n",(0,r.jsxs)(t.h3,{id:"plugging-into-flatlist--legendlist",children:["Plugging into ",(0,r.jsx)(t.code,{children:"FlatList"})," / ",(0,r.jsx)(t.code,{children:"LegendList"})]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"FlatList"})," and ",(0,r.jsx)(t.code,{children:"LegendList"})," require a stable function reference \u2014 wrap the component in ",(0,r.jsx)(t.code,{children:"useCallback"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'import { useCallback } from "react";\nimport { FlatList, type ScrollViewProps } from "react-native";\n\nconst renderScrollComponent = useCallback(\n  (props: ScrollViewProps) => <VirtualizedListScrollView {...props} />,\n  [],\n);\n\n<FlatList\n  data={messages}\n  inverted\n  keyExtractor={(item) => item.id}\n  renderItem={({ item }) => <Message {...item} />}\n  renderScrollComponent={renderScrollComponent}\n/>;\n'})}),"\n",(0,r.jsxs)(t.h3,{id:"handling-the-inverted-prop",children:["Handling the ",(0,r.jsx)(t.code,{children:"inverted"})," prop"]}),"\n",(0,r.jsxs)(t.p,{children:["If your list uses the ",(0,r.jsx)(t.code,{children:"inverted"})," prop (the standard pattern for chat lists where newest messages appear at the bottom), make sure to pass ",(0,r.jsx)(t.code,{children:"inverted"})," to ",(0,r.jsx)(t.code,{children:"KeyboardChatScrollView"})," as well:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",metastring:'title="VirtualizedListScrollView.tsx"',children:"const VirtualizedListScrollView = forwardRef<\n  Ref,\n  ScrollViewProps & KeyboardChatScrollViewProps\n>(({ inverted, ...props }, ref) => {\n  return (\n    <KeyboardChatScrollView\n      ref={ref}\n      // add-new-code\n      inverted={inverted}\n      {...props}\n    />\n  );\n});\n"})}),"\n",(0,r.jsx)(t.h2,{id:"complete-example",children:"Complete example"}),"\n",(0,r.jsxs)(t.p,{children:["Here is a complete chat screen that ties together all the pieces \u2014 ",(0,r.jsx)(t.code,{children:"KeyboardChatScrollView"})," with a ",(0,r.jsx)(t.code,{children:"FlatList"}),", interactive dismissal, sticky input, and safe area handling:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'import React, { forwardRef, useCallback, useRef, useState } from "react";\nimport {\n  FlatList,\n  StyleSheet,\n  TextInput,\n  TouchableOpacity,\n  View,\n  type ScrollViewProps,\n} from "react-native";\nimport {\n  KeyboardChatScrollView,\n  KeyboardGestureArea,\n  KeyboardStickyView,\n} from "react-native-keyboard-controller";\nimport {\n  SafeAreaView,\n  useSafeAreaInsets,\n} from "react-native-safe-area-context";\n\nimport type { KeyboardChatScrollViewProps } from "react-native-keyboard-controller";\n\ntype Ref = React.ElementRef<typeof KeyboardChatScrollView>;\n\nconst MARGIN = 8;\nconst INPUT_HEIGHT = 42;\n\n// Wrapper for virtualized lists\nconst ChatScrollView = forwardRef<\n  Ref,\n  ScrollViewProps & KeyboardChatScrollViewProps\n>((props, ref) => {\n  const { bottom } = useSafeAreaInsets();\n\n  return (\n    <KeyboardChatScrollView\n      ref={ref}\n      automaticallyAdjustContentInsets={false}\n      contentInsetAdjustmentBehavior="never"\n      keyboardDismissMode="interactive"\n      offset={bottom - MARGIN}\n      {...props}\n    />\n  );\n});\n\nfunction ChatScreen() {\n  const textInputRef = useRef<TextInput>(null);\n  const textRef = useRef("");\n  const [messages, setMessages] = useState(INITIAL_MESSAGES);\n  const { bottom } = useSafeAreaInsets();\n\n  const renderScrollComponent = useCallback(\n    (props: ScrollViewProps) => <ChatScrollView {...props} />,\n    [],\n  );\n\n  const onSend = useCallback(() => {\n    const text = textRef.current.trim();\n    if (!text) return;\n\n    setMessages((prev) => [...prev, { id: String(Date.now()), text }]);\n    textInputRef.current?.clear();\n    textRef.current = "";\n  }, []);\n\n  return (\n    <SafeAreaView edges={["bottom"]} style={styles.container}>\n      <KeyboardGestureArea\n        interpolator="ios"\n        offset={INPUT_HEIGHT}\n        style={styles.container}\n        textInputNativeID="chat-input"\n      >\n        <FlatList\n          data={messages}\n          inverted\n          contentContainerStyle={{ paddingTop: INPUT_HEIGHT + MARGIN }}\n          keyExtractor={(item) => item.id}\n          renderItem={({ item }) => <Message {...item} />}\n          renderScrollComponent={renderScrollComponent}\n        />\n        <KeyboardStickyView\n          offset={{ opened: bottom - MARGIN }}\n          style={styles.composer}\n        >\n          <TextInput\n            ref={textInputRef}\n            multiline\n            nativeID="chat-input"\n            placeholder="Type a message..."\n            style={styles.input}\n            onChangeText={(text) => (textRef.current = text)}\n          />\n          <TouchableOpacity onPress={onSend}>\n            <Text>Send</Text>\n          </TouchableOpacity>\n        </KeyboardStickyView>\n      </KeyboardGestureArea>\n    </SafeAreaView>\n  );\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:"Or play with the code in live mode directly in the browser:"}),"\n",(0,r.jsx)("div",{"data-snack-id":"@kirylziusko/c0b7f0","data-snack-platform":"ios","data-snack-preview":"true","data-snack-theme":"light",style:{overflow:"hidden",background:"#fbfcfd",border:"1px solid var(--color-border)",borderRadius:4,height:505,width:"100%"}}),"\n",(0,r.jsx)(n,{children:(0,r.jsx)("script",{src:"https://snack.expo.dev/embed.js",async:!0})}),"\n",(0,r.jsx)(t.h2,{id:"api-reference",children:"API reference"}),"\n",(0,r.jsxs)(t.p,{children:["For the full list of props and design principles, see the ",(0,r.jsxs)(t.a,{href:"../api/components/keyboard-chat-scroll-view",children:[(0,r.jsx)(t.code,{children:"KeyboardChatScrollView"})," API reference"]}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(t.admonition,{title:"Check troubleshooting section first",type:"danger",children:(0,r.jsxs)(t.p,{children:["If you encounter any issues with ",(0,r.jsx)(t.code,{children:"KeyboardChatScrollView"}),", please check the ",(0,r.jsx)(t.a,{href:"../api/components/keyboard-chat-scroll-view#troubleshooting",children:"Troubleshooting section"})," first before reporting a bug. If you're still having trouble, feel free to ",(0,r.jsx)(t.a,{href:"https://github.com/kirillzyusko/react-native-keyboard-controller/issues/new",children:"open an issue"})," on GitHub."]})})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);